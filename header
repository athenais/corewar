./srcs/asm_tools.c:	inst->dir_size = file->op_tab[inst->index].dir_size;
./srcs/asm_tools.c:	if (file->op_tab[inst->index].ocp)
./srcs/asm_tools.c:		inst->wr_size = file->hd->prog_size + 2;
./srcs/asm_tools.c:		inst->wr_size = file->hd->prog_size + 1;
./srcs/assembler.c:	file->fd = fd;
./srcs/assembler.c:	file->hd = malloc(sizeof(t_header));
./srcs/assembler.c:	ft_memset(file->hd, '\0', sizeof(t_header));
./srcs/assembler.c:	file->cor = ft_strnew(ptr - file_name + 4);
./srcs/assembler.c:	ft_strncpy(file->cor, file_name, ptr - file_name);
./srcs/assembler.c:	file->cor = ft_strnjoinfree(file->cor, ".cor", 4);
./srcs/assembler.c:	file->op_tab = g_op_tab;
./srcs/assembler.c:	file->label = NULL;
./srcs/assembler.c:	file->lab_list = NULL;
./srcs/assembler.c:	file->header = 0;
./srcs/assembler.c:	file->wr_buff = malloc(sizeof(uint8_t) * 5000);
./srcs/assembler.c:	ft_fast_bzero(file->wr_buff, 5000);
./srcs/free.c:	free_label(file->label, file->lab_list);
./srcs/free.c:	if (file->fd_cor)
./srcs/free.c:		close(file->fd_cor);
./srcs/free.c:	if (file->fd != -1)
./srcs/free.c:		close(file->fd);
./srcs/free.c:	free((void *)file->hd);
./srcs/free.c:	free((void *)file->cor);
./srcs/free.c:	free((void *)file->wr_buff);
./srcs/get_header.c:			ft_strncpy(file->hd->prog_name, *end + 1, size);
./srcs/get_header.c:			if (!file->hd->comment)
./srcs/get_header.c:			ft_strncpy(file->hd->comment, *end + 1, size);
./srcs/handle_instructions.c:	arg = file->op_tab[inst->index].arg;
./srcs/handle_instructions.c:	while (arg-- && i++ < file->op_tab[inst->index].arg)
./srcs/handle_instructions.c:	if ((inst.index = is_instruction(*wd, file->op_tab)) < 0)
./srcs/handle_label.c:	if (!(new = new_lab(*str, file->hd->prog_size, inst->wr_size, inst->oct)))
./srcs/handle_label.c:	if (file->lab_list == NULL)
./srcs/handle_label.c:		file->lab_list = new;
./srcs/handle_label.c:		tmp = file->lab_list;
./srcs/handle_label.c:	if (file->label == NULL)
./srcs/handle_label.c:		file->label = new;
./srcs/handle_label.c:		tmp = file->label;
./srcs/handle_label.c:	if (make_label(wd, file, file->hd->prog_size) == NULL)
./srcs/read_file.c:		else if (is_instruction(start, file->op_tab) != EXIT_ERROR)
./srcs/read_file.c:	file->line = 1;
./srcs/read_file.c:	file->bytes = 0;
./srcs/read_file.c:	while ((ret = ft_readline(file->fd, &string, &buffer)) > 0)
./srcs/read_file.c:		file->line++;
./srcs/write_inst.c:	type = file->op_tab[index].type[arg];
./srcs/write_inst.c:	file->hd->prog_size += write_to_cor(inst.ocp, c, file);
./srcs/write_inst.c:	while (++arg < file->op_tab[inst.index].arg)
./srcs/write_inst.c:			type = (file->op_tab[inst.index].dir_size) ? shrt : i;
./srcs/write_inst.c:		file->hd->prog_size += write_to_cor(inst.param[arg], type, file);
./srcs/write_inst.c:	op_code = file->op_tab[inst.index].op_code;
./srcs/write_inst.c:	file->hd->prog_size += write_to_cor(op_code, c, file);
./srcs/write_inst.c:	if (file->op_tab[inst.index].ocp)
./srcs/write_inst.c:		if (tmp != file->op_tab[inst.index].type[0])
./srcs/write_inst.c:		type = (file->op_tab[inst.index].dir_size) ? shrt : i;
./srcs/write_inst.c:		file->hd->prog_size += write_to_cor(inst.param[0], type, file);
./srcs/write_label.c:	tmp = file->label;
./srcs/write_label.c:	lseek(file->fd_cor, off_set, SEEK_SET);
./srcs/write_label.c:	file->header = 1;
./srcs/write_label.c:	if (!(file->lab_list))
./srcs/write_label.c:	tmp = file->lab_list;
./srcs/write_to_cor.c:	str = (len == COMMENT_LENGTH) ? file->hd->comment : file->hd->prog_name;
./srcs/write_to_cor.c:	write_to_cor(file->hd->prog_size, i, file);
./srcs/write_to_cor.c:	if ((file->fd_cor = open(file->cor, O_CREAT | O_WRONLY
./srcs/write_to_cor.c:	write(file->fd_cor, file->hd, sizeof(t_header));
./srcs/write_to_cor.c:	while (++i < file->hd->prog_size)
./srcs/write_to_cor.c:		ft_putchar_fd(file->wr_buff[i], file->fd_cor);
./srcs/write_to_cor.c:	lseek(file->fd_cor, 0, SEEK_SET);
./srcs/write_to_cor.c:			if (!file->header)
./srcs/write_to_cor.c:				file->wr_buff[size] = *buff;
./srcs/write_to_cor.c:				ft_putchar_fd(*buff, file->fd_cor);
./srcs/write_to_cor.c:			if (!file->header && size++ == 5000)
